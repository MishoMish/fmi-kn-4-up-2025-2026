# **ТЕОРИЯ - АДРЕСНА АРИТМЕТИКА**

---

# _КАКВО Е АДРЕСНА АРИТМЕТИКА?_

## Основни понятия

**Адресната аритметика** е техника в C++, която позволява математически операции върху **указатели** (pointers). Тя дава възможност да "пътуваме" през паметта, достъпвайки различни елементи на масиви или динамично заделена памет.

### Защо е важна адресната аритметика?

1. ✅ **Ефективност** - директен достъп до паметта без индекси
2. ✅ **Гъвкавост** - обхождане на масиви по различни начини
3. ✅ **Основа за сложни структури** - списъци, дървета, графи
4. ✅ **Разбиране на паметта** - как работи компютърът на ниско ниво
5. ✅ **Предаване на масиви във функции** - масивите са всъщност указатели

---

## 1) ОСНОВИ НА УКАЗАТЕЛИТЕ (REFRESH)

### Какво е указател?

**Указател** е променлива, която съхранява **адрес в паметта**.

```cpp
int x = 42;
int* ptr = &x;  // ptr съхранява адреса на x

// Визуализация:
// ┌─────────────┬──────────┐
// │   Адрес     │ Стойност │
// ├─────────────┼──────────┤
// │   0x1000    │    42    │ ← x
// ├─────────────┼──────────┤
// │   0x1004    │  0x1000  │ ← ptr (съдържа адреса на x)
// └─────────────┴──────────┘
```

### Основни операции:

```cpp
int x = 10;
int* ptr = &x;    // & = адрес на x
int value = *ptr; // * = стойността на адреса (дереференция)

std::cout << x;      // 10 (стойността на x)
std::cout << &x;     // 0x1000 (адресът на x)
std::cout << ptr;    // 0x1000 (адресът съхранен в ptr)
std::cout << *ptr;   // 10 (стойността на адреса в ptr)
```

---

## 2) МАСИВИ И УКАЗАТЕЛИ

### Ключова връзка: Масивът Е указател!

Когато декларираме масив, **името му е указател** към първия елемент.

```cpp
int arr[5] = {10, 20, 30, 40, 50};

// arr е указател към arr[0]
// arr === &arr[0]
```

### Визуализация на масив в паметта:

```
Масив: int arr[5] = {10, 20, 30, 40, 50};

┌──────────┬─────────┬─────────┬─────────┬─────────┬─────────┐
│  Адрес   │ 0x1000  │ 0x1004  │ 0x1008  │ 0x100C  │ 0x1010  │
├──────────┼─────────┼─────────┼─────────┼─────────┼─────────┤
│ Стойност │   10    │   20    │   30    │   40    │   50    │
├──────────┼─────────┼─────────┼─────────┼─────────┼─────────┤
│ Индекс   │  arr[0] │ arr[1]  │ arr[2]  │ arr[3]  │ arr[4]  │
└──────────┴─────────┴─────────┴─────────┴─────────┴─────────┘
           ↑
          arr (указател към началото)
```

**💡 Важно:** Всеки `int` заема **4 bytes** в паметта!

### Еквивалентни начини за достъп:

```cpp
int arr[5] = {10, 20, 30, 40, 50};

// Достъп до първия елемент (4 начина):
arr[0]        // Чрез индекс
*arr          // Дереференция на указателя
*(arr + 0)    // Адресна аритметика
*&arr[0]      // Адрес + дереференция

// Достъп до втория елемент:
arr[1]        // Чрез индекс
*(arr + 1)    // Адресна аритметика
```

---

## 3) АДРЕСНА АРИТМЕТИКА - ОСНОВНИ ОПЕРАЦИИ

### Операции върху указатели:

#### ➕ Събиране (ptr + n)

**Идея:** "Помести се n елемента напред"

```cpp
int arr[5] = {10, 20, 30, 40, 50};
int* ptr = arr;  // ptr сочи към arr[0]

ptr + 0  →  сочи към arr[0] (адрес 0x1000)
ptr + 1  →  сочи към arr[1] (адрес 0x1004)
ptr + 2  →  сочи към arr[2] (адрес 0x1008)
ptr + 3  →  сочи към arr[3] (адрес 0x100C)
```

**⚠️ ВАЖНО:** При `ptr + 1` адресът се увеличава с `sizeof(int) = 4` bytes, НЕ с 1 byte!

```
ptr + 1  →  адрес увеличава с 1 × sizeof(int) = 1 × 4 = 4 bytes
ptr + 2  →  адрес увеличава с 2 × sizeof(int) = 2 × 4 = 8 bytes
ptr + n  →  адрес увеличава с n × sizeof(тип)
```

#### ➖ Изваждане (ptr - n)

**Идея:** "Помести се n елемента назад"

```cpp
int arr[5] = {10, 20, 30, 40, 50};
int* ptr = &arr[4];  // ptr сочи към последния елемент

ptr - 0  →  сочи към arr[4] (адрес 0x1010)
ptr - 1  →  сочи към arr[3] (адрес 0x100C)
ptr - 2  →  сочи към arr[2] (адрес 0x1008)
ptr - 3  →  сочи към arr[1] (адрес 0x1004)
ptr - 4  →  сочи към arr[0] (адрес 0x1000)
```

#### 📊 Визуализация на ptr + n:

```
int arr[5] = {10, 20, 30, 40, 50};
int* ptr = arr;

ptr        →  ┌─────┐
              │ 10  │ arr[0]
              ├─────┤
ptr + 1    →  │ 20  │ arr[1]
              ├─────┤
ptr + 2    →  │ 30  │ arr[2]
              ├─────┤
ptr + 3    →  │ 40  │ arr[3]
              ├─────┤
ptr + 4    →  │ 50  │ arr[4]
              └─────┘
```

---

## 4) ДЕРЕФЕРЕНЦИЯ + АДРЕСНА АРИТМЕТИКА

### Комбинация *(ptr + n)

**Идея:** "Вземи стойността n елемента напред"

```cpp
int arr[5] = {10, 20, 30, 40, 50};
int* ptr = arr;

*(ptr + 0)  →  10  // Стойността на arr[0]
*(ptr + 1)  →  20  // Стойността на arr[1]
*(ptr + 2)  →  30  // Стойността на arr[2]
*(ptr + 3)  →  40  // Стойността на arr[3]
*(ptr + 4)  →  50  // Стойността на arr[4]
```

### Еквиваленти:

```cpp
arr[i]  ≡  *(arr + i)
ptr[i]  ≡  *(ptr + i)

// Пример:
arr[2] == *(arr + 2) == 30
```

### 📝 Примери на дъската:

```cpp
int arr[5] = {10, 20, 30, 40, 50};
int* ptr = arr + 2;  // ptr сочи към arr[2]

// Въпроси за дъската:
*ptr           = ?
*(ptr + 1)     = ?
*(ptr - 1)     = ?
*(ptr + 2)     = ?
ptr[0]         = ?
ptr[1]         = ?
ptr[-1]        = ?
```

<details>
<summary><b>📝 Отговори</b></summary>

- `*ptr` → **30**
- `*(ptr + 1)` → **40**
- `*(ptr - 1)` → **20**
- `*(ptr + 2)` → **50**
- `ptr[0]` → **30**
- `ptr[1]` → **40**
- `ptr[-1]` → **20**

</details>

**Визуализация:**

```
arr: [10, 20, 30, 40, 50]
           ↑
          ptr (сочи към arr[2])

ptr - 2  ptr - 1   ptr   ptr + 1  ptr + 2
  ↓        ↓       ↓        ↓        ↓
 [10]    [20]    [30]    [40]    [50]
```

---

## 5) ИНКРЕМЕНТИРАНЕ И ДЕКРЕМЕНТИРАНЕ

### Операции ++ и --

```cpp
int arr[5] = {10, 20, 30, 40, 50};
int* ptr = arr;

ptr++;    // ptr сега сочи към arr[1]
ptr--;    // ptr отново сочи към arr[0]
++ptr;    // ptr сочи към arr[1]
--ptr;    // ptr отново сочи към arr[0]
```

### Визуализация на движение:

```
Начало:
ptr  →  [10] [20] [30] [40] [50]

След ptr++:
        [10] [20] [30] [40] [50]
              ↑
             ptr

След ptr++:
        [10] [20] [30] [40] [50]
                   ↑
                  ptr

След ptr--:
        [10] [20] [30] [40] [50]
              ↑
             ptr
```

### Обхождане на масив с указател:

```cpp
int arr[5] = {10, 20, 30, 40, 50};
int* ptr = arr;

// Обхождане напред
for (int i = 0; i < 5; i++) {
    std::cout << *ptr << " ";
    ptr++;  // Преместваме към следващия елемент
}
// Изход: 10 20 30 40 50

// ptr сега е извън масива! Не е безопасно да го дереференцираме
```

---

## 6) СРАВНЯВАНЕ НА УКАЗАТЕЛИ

### Операции за сравнение:

```cpp
int arr[5] = {10, 20, 30, 40, 50};
int* ptr1 = arr;
int* ptr2 = arr + 3;

ptr1 < ptr2   →  true  (ptr1 е "по-рано" в паметта)
ptr1 > ptr2   →  false
ptr1 == ptr2  →  false
ptr1 != ptr2  →  true

// След ptr1 += 3:
ptr1 == ptr2  →  true  (сочат към същото място)
```

### Изваждане на указатели:

```cpp
int arr[5] = {10, 20, 30, 40, 50};
int* ptr1 = arr;
int* ptr2 = arr + 4;

ptr2 - ptr1  →  4  // Разстоянието между тях (в брой елементи)
ptr1 - ptr2  →  -4
```

---

## 7) АДРЕСНА АРИТМЕТИКА В ЦИКЛИ

### Pattern 1: Обхождане с указател

```cpp
int arr[5] = {10, 20, 30, 40, 50};

// Вариант 1: Индекси (класически)
for (int i = 0; i < 5; i++) {
    std::cout << arr[i] << " ";
}

// Вариант 2: Адресна аритметика (без инкремент)
for (int i = 0; i < 5; i++) {
    std::cout << *(arr + i) << " ";
}

// Вариант 3: Движещ се указател
int* ptr = arr;
int* end = arr + 5;
for (; ptr < end; ptr++) {
    std::cout << *ptr << " ";
}

// Вариант 4: Указател с броене
int* ptr = arr;
for (int i = 0; i < 5; i++) {
    std::cout << *ptr << " ";
    ptr++;
}
```

### Pattern 2: Два указателя

```cpp
int arr[5] = {10, 20, 30, 40, 50};

int* left = arr;          // Сочи към началото
int* right = arr + 4;     // Сочи към края

// Размяна на краищата
while (left < right) {
    int temp = *left;
    *left = *right;
    *right = temp;
    
    left++;
    right--;
}
// Резултат: [50, 40, 30, 20, 10]
```

**Визуализация:**

```
Начало:
left                        right
 ↓                            ↓
[10]  [20]  [30]  [40]  [50]

След размяна и движение:
      left          right
       ↓              ↓
[50]  [20]  [30]  [40]  [10]

След размяна и движение:
            left
           right
             ↓
[50]  [40]  [30]  [20]  [10]
```

---

## 8) ДИНАМИЧНА ПАМЕТ И АДРЕСНА АРИТМЕТИКА

### Работа с динамични масиви:

```cpp
int n = 5;
int* arr = new int[n];  // Динамично заделяме масив

// Попълване чрез адресна аритметика
for (int i = 0; i < n; i++) {
    *(arr + i) = i * 10;
}

// arr сега съдържа: [0, 10, 20, 30, 40]

// Обхождане
int* ptr = arr;
int* end = arr + n;
while (ptr < end) {
    std::cout << *ptr << " ";
    ptr++;
}

delete[] arr;  // ⚠️ НЕ ЗАБРАВЯЙТЕ!
```

### Визуализация на динамична памет:

```
Stack (стек):                  Heap (динамична памет):
┌───────────┐                 ┌─────┬─────┬─────┬─────┬─────┐
│  n = 5    │                 │  0  │ 10  │ 20  │ 30  │ 40  │
├───────────┤                 └─────┴─────┴─────┴─────┴─────┘
│ arr = ●───┼────────────────────→ ↑
└───────────┘                      Heap address (напр. 0x2000)

Адреси:     0x2000  0x2004  0x2008  0x200C  0x2010

arr + 0  →  0x2000
arr + 1  →  0x2004
arr + 2  →  0x2008
```

---

## 9) КЪДЕ МОЖЕ И КЪДЕ НЕ МОЖЕ АДРЕСНА АРИТМЕТИКА

### ✅ МОЖЕ (Валидни операции):

#### 1. Статични масиви:
```cpp
int arr[5] = {1, 2, 3, 4, 5};
int* ptr = arr;
ptr + 2;     // ✅ OK
*(ptr + 3);  // ✅ OK
```

#### 2. Динамични масиви:
```cpp
int* arr = new int[5];
int* ptr = arr + 2;  // ✅ OK
*(arr + 4);          // ✅ OK
delete[] arr;
```

#### 3. Параметри във функции:
```cpp
void processArray(int* arr, int size) {
    for (int i = 0; i < size; i++) {
        *(arr + i) *= 2;  // ✅ OK
    }
}
```

#### 4. Изваждане на указатели:
```cpp
int arr[5];
int* ptr1 = arr;
int* ptr2 = arr + 3;
int distance = ptr2 - ptr1;  // ✅ OK (резултат: 3)
```

### ❌ НЕ МОЖЕ (Невалидни операции):

#### 1. Обикновени променливи:
```cpp
int x = 10;
int* ptr = &x;
ptr + 1;     // ⚠️ UNDEFINED BEHAVIOR (не сочи към валидна памет)
*(ptr + 1);  // ❌ ОПАСНО! Достъп до случайна памет
```

**Обяснение:** `x` е **една променлива**, не масив. След `ptr + 1` сочим към неопределено място!

```
Памет:
┌───────────┬───────────┬───────────┐
│    x      │  случаен  │  случаен  │
│   (10)    │   боклук  │   боклук  │
└───────────┴───────────┴───────────┘
     ↑           ↑
    ptr      ptr + 1 (⚠️ невалидно!)
```

#### 2. Събиране на два указателя:
```cpp
int arr[5];
int* ptr1 = arr;
int* ptr2 = arr + 2;
ptr1 + ptr2;  // ❌ ГРЕШКА! Не може да събираме указатели
```

**Обяснение:** Събирането на два указателя **няма математически смисъл**!

Указателите съхраняват **адреси в паметта**. Какво означава да съберем два адреса?
- `ptr1` сочи към адрес `0x1000`
- `ptr2` сочи към адрес `0x1008`
- `ptr1 + ptr2` = `0x1000 + 0x1008` = `0x2008` ← Какво е това? 🤔

Резултатът `0x2008` е **случаен адрес**, който не принадлежи към нашия масив и няма логическо значение!

```
Масив: [10, 20, 30, 40, 50]
        ↑           ↑
      ptr1        ptr2
     0x1000      0x1008

ptr1 + ptr2 = 0x2008 ← Сочи ли към нещо полезно? НЕ!
```

**Валидни операции:**
- ✅ `ptr + число` → премести се напред
- ✅ `ptr - число` → премести се назад  
- ✅ `ptr2 - ptr1` → колко елемента между тях (разстояние)
- ❌ `ptr1 + ptr2` → безсмислено!

#### 3. Умножение/деление:
```cpp
int* ptr = arr;
ptr * 2;      // ❌ ГРЕШКА!
ptr / 2;      // ❌ ГРЕШКА!
```

**Обяснение:** Умножението и делението на указатели **не са дефинирани операции**!

Нека `ptr` сочи към адрес `0x1000`. Какво означава да умножим адрес по 2?
- `ptr * 2` = `0x1000 * 2` = `0x2000` ← Какво е това? 🤔
- Това е просто **случаен адрес**, който вероятно **не е част от масива**!

```
Масив: [10, 20, 30, 40, 50]
        ↑
       ptr
     0x1000

ptr * 2 = 0x2000 ← Извън масива! Опасно!
ptr / 2 = 0x0800 ← Преди масива! Опасно!
```

**Защо е грешка:**
1. **Няма логически смисъл** - какво означава "удвои адреса"?
2. **Не работи с размера на типа** - `ptr + 1` се измества с `sizeof(int)`, но `ptr * 2` не прави това
3. **Води до невалидна памет** - резултатът сочи към случайно място
4. **Компилаторът не позволява** - това е синтактична грешка в C++

**Какво искате да постигнете?**
- Ако искате да се преместите 2 елемента → използвайте `ptr + 2` ✅
- Ако искате да удвоите **стойността** → използвайте `*ptr * 2` ✅
- Ако искате да удвоите адреса → вероятно грешите в логиката! ❌

#### 4. Извън границите:
```cpp
int arr[5] = {1, 2, 3, 4, 5};
int* ptr = arr;
*(ptr + 10);  // ⚠️ UNDEFINED BEHAVIOR (извън масива)
*(ptr - 1);   // ⚠️ UNDEFINED BEHAVIOR (преди масива)
```

**Визуализация на невалиден достъп:**

```
Валидна памет:     Невалидна памет:
┌─────┬─────┬─────┬─────┬─────┬──────────┬──────────┐
│  1  │  2  │  3  │  4  │  5  │ боклук  │ боклук  │
└─────┴─────┴─────┴─────┴─────┴──────────┴──────────┘
  ↑                           ↑           ↑
 arr                      arr + 5     arr + 10
                            ⚠️          ❌
```

#### 5. Освободена памет:
```cpp
int* arr = new int[5];
delete[] arr;
arr + 2;     // ⚠️ Указателят е валиден, НО...
*(arr + 2);  // ❌ ОПАСНО! Паметта е освободена
```

---

## 10) ТИПОВЕ ДАННИ И РАЗМЕРИ

### sizeof() и адресна аритметика:

```cpp
int arr_int[3];      // sizeof(int) = 4 bytes
double arr_dbl[3];   // sizeof(double) = 8 bytes
char arr_char[3];    // sizeof(char) = 1 byte
```

### Как компилаторът изчислява адреси:

```cpp
int* ptr = arr_int;
ptr + 1  →  адрес увеличава с 1 × 4 = 4 bytes

double* ptr = arr_dbl;
ptr + 1  →  адрес увеличава с 1 × 8 = 8 bytes

char* ptr = arr_char;
ptr + 1  →  адрес увеличава с 1 × 1 = 1 byte
```

### Визуализация:

```
int масив (4 bytes на елемент):
┌─────────┬─────────┬─────────┐
│ 0x1000  │ 0x1004  │ 0x1008  │
├─────────┼─────────┼─────────┤
│  arr[0] │ arr[1]  │ arr[2]  │
└─────────┴─────────┴─────────┘
    ptr    ptr + 1   ptr + 2

double масив (8 bytes на елемент):
┌─────────┬─────────┬─────────┐
│ 0x1000  │ 0x1008  │ 0x1010  │
├─────────┼─────────┼─────────┤
│  arr[0] │ arr[1]  │ arr[2]  │
└─────────┴─────────┴─────────┘
    ptr    ptr + 1   ptr + 2

char масив (1 byte на елемент):
┌────┬────┬────┐
│0x1000│0x1001│0x1002│
├────┼────┼────┤
│arr[0]│arr[1]│arr[2]│
└────┴────┴────┘
 ptr ptr+1 ptr+2
```

---

## 11) ПРАКТИЧЕСКИ ПРИМЕРИ

### Пример 1: Намиране на минимум с указатели

```cpp
int findMin(int* arr, int size) {
    int min = *arr;  // Първият елемент
    
    for (int* ptr = arr + 1; ptr < arr + size; ptr++) {
        if (*ptr < min) {
            min = *ptr;
        }
    }
    
    return min;
}

// Използване:
int arr[5] = {30, 10, 50, 20, 40};
int minimum = findMin(arr, 5);  // 10
```

### Пример 2: Обръщане на масив

```cpp
void reverseArray(int* arr, int size) {
    int* left = arr;
    int* right = arr + size - 1;
    
    while (left < right) {
        // Размяна
        int temp = *left;
        *left = *right;
        *right = temp;
        
        left++;
        right--;
    }
}

// Използване:
int arr[5] = {1, 2, 3, 4, 5};
reverseArray(arr, 5);
// Резултат: [5, 4, 3, 2, 1]
```

### Пример 3: Копиране на масив

```cpp
void copyArray(int* source, int* destination, int size) {
    int* src_ptr = source;
    int* dst_ptr = destination;
    int* end = source + size;
    
    while (src_ptr < end) {
        *dst_ptr = *src_ptr;
        src_ptr++;
        dst_ptr++;
    }
}

// Или по-компактно:
void copyArray(int* source, int* destination, int size) {
    for (int* end = source + size; source < end; ) {
        *destination++ = *source++;
    }
}
```

---

## 12) ЗАДАЧИ ЗА ДЪСКАТА

### Задача 1: Какво ще се изведе?

```cpp
int arr[5] = {10, 20, 30, 40, 50};
int* ptr = arr + 2;

std::cout << *ptr << std::endl;        // ?
std::cout << *(ptr + 1) << std::endl;  // ?
std::cout << *(ptr - 2) << std::endl;  // ?
std::cout << ptr[1] << std::endl;      // ?
std::cout << ptr[-1] << std::endl;     // ?
```

<details>
<summary><b>📝 Отговори</b></summary>

```
30
40
10
40
20
```

</details>

### Задача 2: Попълнете адресите

```cpp
int arr[4] = {5, 10, 15, 20};
// Нека адресът на arr[0] е 0x2000

// Попълнете таблицата:
// ┌───────────┬─────────┬──────────┐
// │  Израз    │  Адрес  │ Стойност │
// ├───────────┼─────────┼──────────┤
// │  arr      │    ?    │    ?     │
// │  arr + 1  │    ?    │    ?     │
// │  arr + 2  │    ?    │    ?     │
// │  &arr[3]  │    ?    │    ?     │
// │  *arr     │    ?    │    ?     │
// │  *(arr+2) │    ?    │    ?     │
// └───────────┴─────────┴──────────┘
```

<details>
<summary><b>📝 Отговори</b></summary>

```
┌───────────┬─────────┬──────────┐
│  Израз    │  Адрес  │ Стойност │
├───────────┼─────────┼──────────┤
│  arr      │ 0x2000  │  0x2000  │
│  arr + 1  │ 0x2004  │  0x2004  │
│  arr + 2  │ 0x2008  │  0x2008  │
│  &arr[3]  │ 0x200C  │  0x200C  │
│  *arr     │   -     │    5     │
│  *(arr+2) │   -     │   15     │
└───────────┴─────────┴──────────┘
```

</details>

### Задача 3: Проследете указателя

```cpp
int arr[5] = {1, 2, 3, 4, 5};
int* ptr = arr;

ptr += 2;    // Къде сочи ptr сега?
*ptr = 10;   // Какво става с масива?
ptr--;       // Къде сочи ptr сега?
(*ptr)++;    // Какво става с масива?

// Какъв е масивът в края?
```

<details>
<summary><b>📝 Отговор</b></summary>

**Масивът в края:** `[1, 3, 10, 4, 5]`

**Стъпка по стъпка:**
1. `ptr += 2` → ptr сочи към arr[2] (стойност 3)
2. `*ptr = 10` → arr[2] става 10 → `[1, 2, 10, 4, 5]`
3. `ptr--` → ptr сочи към arr[1] (стойност 2)
4. `(*ptr)++` → arr[1] става 3 → `[1, 3, 10, 4, 5]`

</details>

---

## 13) ЧЕСТО СРЕЩАНИ ГРЕШКИ

### ❌ Грешка 1: Забравяне на дереференция

```cpp
int arr[5] = {10, 20, 30, 40, 50};
int* ptr = arr;

ptr + 1 = 100;  // ❌ ГРЕШКА! Опит да променим адреса
*(ptr + 1) = 100;  // ✅ Правилно! Променяме стойността
```

### ❌ Грешка 2: Изход извън границите

```cpp
int arr[5] = {1, 2, 3, 4, 5};
int* ptr = arr;

for (int i = 0; i <= 5; i++) {  // ❌ ГРЕШКА! i <= 5
    *(ptr + i) = 0;
}

// Правилно:
for (int i = 0; i < 5; i++) {  // ✅ i < 5
    *(ptr + i) = 0;
}
```

### ❌ Грешка 3: Използване след delete

```cpp
int* arr = new int[5];
delete[] arr;
*arr = 10;  // ❌ ОПАСНО! Паметта е освободена
```

### ❌ Грешка 4: Губене на началото

```cpp
int* arr = new int[5];
arr++;  // ⚠️ Сега arr не сочи към началото!
delete[] arr;  // ❌ ГРЕШКА! Трябва да изтрием от началото
```

**Правилно:**

```cpp
int* arr = new int[5];
int* ptr = arr;
ptr++;  // Използваме временен указател
delete[] arr;  // ✅ Изтриваме оригиналния
```

---

## 14) ДОБРИ ПРАКТИКИ

### ✅ Практика 1: Винаги проверявайте границите

```cpp
int* ptr = arr;
if (ptr >= arr && ptr < arr + size) {
    *ptr = value;  // Безопасно
}
```

### ✅ Практика 2: Използвайте const за read-only

```cpp
void printArray(const int* arr, int size) {
    for (int i = 0; i < size; i++) {
        std::cout << *(arr + i) << " ";
        // arr[i] = 0;  // ❌ Грешка! arr е const
    }
}
```

### ✅ Практика 3: Запазете оригиналния указател

```cpp
int* original = new int[5];
int* ptr = original;  // Работим с копие

// ... операции с ptr ...

delete[] original;  // Изтриваме оригиналния
```

### ✅ Практика 4: Nullify след delete

```cpp
int* arr = new int[5];
delete[] arr;
arr = nullptr;  // Предотвратява случайно използване
```

---

## 15) ОБОБЩЕНИЕ

### Ключови концепции:

1. **Масивът е указател** към първия елемент
2. **ptr + n** се измества с `n × sizeof(тип)` bytes
3. ***(ptr + n)** е еквивалентно на **ptr[n]**
4. **Валидни операции:** +, -, ++, --, сравнение, изваждане
5. **Невалидни операции:** събиране на два указателя, умножение, деление

### Формули:

```
arr[i]      ≡  *(arr + i)
&arr[i]     ≡  arr + i
ptr + n     →  адрес + (n × sizeof(тип))
ptr2 - ptr1 →  брой елементи между тях
```

### Когато използваме:

✅ Обхождане на масиви  
✅ Динамични структури  
✅ Ефективни алгоритми  
✅ Работа с функции и масиви  

### Когато избягваме:

❌ Обикновени променливи (не масиви)  
❌ След delete/free  
❌ Извън границите на масива  
❌ Когато индексите са по-ясни  

---

**Успех с адресната аритметика! 🎯**

_Помнете: С голямата сила идва голяма отговорност. Адресната аритметика е мощна, но изисква внимание!_
