# **ТЕОРИЯ - ПРОГРАМЕН СТЕК И ДИНАМИЧНА ПАМЕТ**

---

# _КАКВО Е ПРОГРАМЕН СТЕК?_

## 1) Основни понятия за памет в C++

Когато вашата програма се изпълнява, компютърът разпределя памет по различни начини. Има **два основни типа памет**, които трябва да познавате:

### 📚 **Stack (Стек)** - Автоматична памет

### 🏗️ **Heap (Heap)** - Динамична памет

Преди да разгледаме разликите, нека разберем какво представлява стекът като структура от данни.

---

## 2) [Стек като структура от данни](<https://bg.wikipedia.org/wiki/Стек_(структура_от_данни)>)

Стекът е **линейна структура от данни**, в която обработката на информация става само от **едната страна**, наречена **връх** (top).

### Принцип на работа: **LIFO**

**LIFO** = **L**ast **I**n, **F**irst **O**ut (Последен влязъл, първи излязъл)

Представете си **стек от чинии** 🍽️:

- Когато слагате чиния, тя отива отгоре (**push**)
- Когато вземате чиния, взимате най-горната (**pop**)
- Не можете да вземете чинията отдолу, без да махнете всички отгоре!

### Визуализация:

```
     Операции:           push(3)      push(5)      pop()        pop()

        Стек:              │            │            │            │
                           │            │            │            │
                           ▼            ▼            ▼            ▼

    ┌─────────┐      ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐
    │         │      │    3    │  │    5    │  │    3    │  │         │
    ├─────────┤      ├─────────┤  ├─────────┤  ├─────────┤  ├─────────┤
    │    2    │  →   │    2    │  │    3    │  │    2    │  │    2    │
    ├─────────┤      ├─────────┤  ├─────────┤  ├─────────┤  ├─────────┤
    │    1    │      │    1    │  │    2    │  │    1    │  │    1    │
    └─────────┘      └─────────┘  ├─────────┤  └─────────┘  └─────────┘
                                  │    1    │
                                  └─────────┘
```

### Основни операции:

```
📥 push (добавяне)    – Поставя нов елемент върху стека
📤 pop (изваждане)    – Вади най-горния (последно добавения) елемент
👀 peek (надникване)  – Показва най-горния елемент БЕЗ да го изважда
```

---

## 3) Програмен стек (Call Stack)

В C++ **всяка функция използва стек** за съхранение на:

- 📌 Локални променливи
- 📌 Параметри на функцията
- 📌 Адрес за връщане (къде да се върне след изпълнение)

### 🔹 Характеристики на програмния стек:

| Свойство                      | Описание                                           |
| ----------------------------- | -------------------------------------------------- |
| **1. Автоматично управление** | Паметта се заделя и освобождава **автоматично**    |
| **2. LIFO ред**               | Последната заделена памет се освобождава **първа** |
| **3. Бързина**                | Много **бързо** заделяне и освобождаване           |
| **4. Размер**                 | **Ограничен размер** (обикновено 1-8 MB)           |
| **5. Scope-based**            | Памет се освобождава при **изход от блок** `{}`    |
| **6. Фиксиран размер**        | Размерът се определя при **компилация**            |

### Пример за работа със стека:

```cpp
void func2() {
    int c = 30;        // c отива на стека
    std::cout << c;
}  // c се премахва от стека

void func1() {
    int b = 20;        // b отива на стека
    func2();           // извикване на func2
}  // b се премахва от стека

int main() {
    int a = 10;        // a отива на стека
    func1();           // извикване на func1
    return 0;
}  // a се премахва от стека
```

### Визуализация на стека:

```
    main() се изпълнява:           func1() се изпълнява:         func2() се изпълнява:

    ┌─────────────┐                ┌─────────────┐               ┌─────────────┐
    │             │                │   c = 30    │ ← TOP         │   c = 30    │ ← TOP
    │             │                ├─────────────┤               ├─────────────┤
    │             │                │   b = 20    │               │   b = 20    │
    ├─────────────┤                ├─────────────┤               ├─────────────┤
    │   a = 10    │ ← TOP          │   a = 10    │               │   a = 10    │
    └─────────────┘                └─────────────┘               └─────────────┘

    func2() завърши:               func1() завърши:              main() завърши:

    ┌─────────────┐                ┌─────────────┐               ┌─────────────┐
    │             │                │             │               │             │
    ├─────────────┤                │             │               │             │
    │   b = 20    │ ← TOP          │             │               │             │
    ├─────────────┤                ├─────────────┤               │             │
    │   a = 10    │                │   a = 10    │ ← TOP         │             │
    └─────────────┘                └─────────────┘               └─────────────┘
```

### 💡 Забележки:

- Всяка функция "вижда" само **своите локални променливи**
- Когато функция приключи, **всичките ѝ променливи изчезват**
- Стекът расте **надолу** (към по-ниски адреси в паметта)

---

## 4) Stack Overflow - препълване на стека

Какво се случва ако стекът се препълни? Получаваме **Stack Overflow** грешка! 💥

### Чести причини:

#### 🔴 1. Безкрайна рекурсия:

```cpp
void infiniteRecursion() {
    infiniteRecursion();  // Няма базов случай!
}
```

#### 🔴 2. Прекалено големи локални променливи:

```cpp
void bigArray() {
    int arr[10000000];  // Твърде голям масив за стека!
}
```

#### 🔴 3. Много дълбока рекурсия:

```cpp
int factorial(int n) {
    if (n == 0) return 1;
    return n * factorial(n - 1);
}

// factorial(1000000) → Stack Overflow!
```

---

## 5) Динамична памет (Heap)

За да избегнем ограниченията на стека, използваме **динамична памет** (heap).

### 🔹 Характеристики на heap:

| Свойство                | Описание                                             |
| ----------------------- | ---------------------------------------------------- |
| **1. Ръчно управление** | Програмистът заделя с `new` и освобождава с `delete` |
| **2. Гъвкавост**        | Заделяме памет **по време на изпълнение**            |
| **3. Големина**         | **Много по-голям** от стека (ограничен от RAM)       |
| **4. Бавен**            | По-**бавно** от стека                                |
| **5. Живот**            | Паметта **не се освобождава** автоматично            |
| **6. Динамичен размер** | Размер се определя при **изпълнение**                |

### Заделяне на памет в heap:

```cpp
int* ptr = new int;        // Заделя 1 int в heap
*ptr = 42;                 // Работим с паметта
delete ptr;                // ЗАДЪЛЖИТЕЛНО освобождаваме паметта!
ptr = nullptr;             // Добра практика - нулираме указателя
```

---

## 6) Разлика между Stack и Heap

| **Характеристика** | **Stack (Стек)**                 | **Heap (Динамична памет)**            |
| ------------------ | -------------------------------- | ------------------------------------- |
| **Управление**     | Автоматично от компилатора       | Ръчно от програмиста (`new`/`delete`) |
| **Скорост**        | ⚡ Много бързо                   | 🐌 По-бавно                           |
| **Размер**         | 📏 Ограничен (1-8 MB)            | 📦 Голям (ограничен от RAM)           |
| **Заделяне**       | По време на **компилация**       | По време на **изпълнение**            |
| **Грешки**         | Stack Overflow                   | Memory Leak, Segmentation Fault       |
| **Освобождаване**  | Автоматично при `}`              | Ръчно с `delete`                      |
| **Фрагментация**   | ❌ Няма                          | ✅ Възможна                           |
| **Подходящо за**   | Локални променливи, малки масиви | Големи структури, динамични масиви    |

### Визуално сравнение:

```
           ПАМЕТ НА ПРОГРАМАТА
    ═══════════════════════════════════

         STACK (нагоре)
    ┌─────────────────────────┐
    │  int a = 10;            │  ← Автоматично
    │  char c = 'A';          │
    │  double d = 3.14;       │
    └─────────────────────────┘
              ↕  (расте надолу)

    ─────────────────────────────────

              ↕  (расте нагоре)
         HEAP (надолу)
    ┌─────────────────────────┐
    │  new int[1000];         │  ← Ръчно
    │  new MyClass();         │
    │  new double[500];       │
    └─────────────────────────┘
```

---

## 7) Работа с динамична памет - `new` и `delete`

### 🔸 Заделяне на единична променлива:

```cpp
int* q = new int(5);     // Заделя int в heap и го инициализира с 5
*q = 10;                 // Променяме стойността
std::cout << *q;         // Извеждаме стойността
delete q;                // Освобождаваме паметта
q = nullptr;             // Добра практика
```

### 🔸 Заделяне на масив:

```cpp
int size = 100;
int* arr = new int[size];    // Заделя масив от 100 int-а

for (int i = 0; i < size; i++) {
    arr[i] = i * 2;
}

delete[] arr;                // ВАЖНО: delete[] за масиви!
arr = nullptr;
```

### ⚠️ Важни правила:

```cpp
// ❌ ГРЕШНО:
int* arr = new int[10];
delete arr;           // БЕЗ []! Undefined behavior!

// ✅ ПРАВИЛНО:
int* arr = new int[10];
delete[] arr;         // С [] за масиви!
```

---

## 8) Memory Leak - Изтичане на памет

**Memory leak** възниква, когато заделена памет **не се освободи** с `delete`.

### 🔴 Пример за Memory Leak:

```cpp
void badFunction() {
    int* ptr = new int(42);
    // Забравяме delete ptr;
}  // ptr изчезва, но паметта остава заделена!

int main() {
    for (int i = 0; i < 1000000; i++) {
        badFunction();  // Всяко извикване "изтича" памет!
    }
    // След време програмата ще се срине!
}
```

### ✅ Правилен подход:

```cpp
void goodFunction() {
    int* ptr = new int(42);
    // Работим с ptr...
    delete ptr;       // Освобождаваме паметта!
    ptr = nullptr;    // Нулираме указателя
}
```

### 💡 Защо е опасно?

1. 💾 **Запълва паметта** - В даден момент няма да има свободна памет
2. ⚠️ **Crash на програмата** - При изчерпване на памет
3. 🐛 **Трудно откриване** - Memory leak-овете са трудни за дебъгване
4. 🖥️ **Проблеми със системата** - Може да забави целия компютър

### 🛡️ Златно правило:

```
За всяко new → трябва да има съответно delete!
За всяко new[] → трябва да има съответно delete[]!
```

---

## 9) Динамични масиви

### Едномерен динамичен масив:

```cpp
int size;
std::cout << "Въведете размер: ";
std::cin >> size;

int* arr = new int[size];  // Създаваме масив по време на изпълнение!

// Попълване
for (int i = 0; i < size; i++) {
    arr[i] = i * i;
}

// Използване
for (int i = 0; i < size; i++) {
    std::cout << arr[i] << " ";
}

delete[] arr;  // Освобождаване
```

### Двумерен динамичен масив (матрица):

```cpp
int rows, cols;
std::cout << "Редове: ";
std::cin >> rows;
std::cout << "Колони: ";
std::cin >> cols;

// Заделяме памет за масив от указатели
int** matrix = new int*[rows];

// Заделяме памет за всеки ред
for (int i = 0; i < rows; i++) {
    matrix[i] = new int[cols];
}

// Попълване
for (int i = 0; i < rows; i++) {
    for (int j = 0; j < cols; j++) {
        matrix[i][j] = i * cols + j;
    }
}

// Извеждане
for (int i = 0; i < rows; i++) {
    for (int j = 0; j < cols; j++) {
        std::cout << matrix[i][j] << " ";
    }
    std::cout << std::endl;
}

// ВАЖНО: Освобождаване в обратен ред!
for (int i = 0; i < rows; i++) {
    delete[] matrix[i];  // Първо редовете
}
delete[] matrix;  // После масива от указатели
```

### Визуализация на 2D масива в паметта:

```
    matrix (stack)
    ┌──────┐
    │ ptr  │──────┐
    └──────┘      │
                  ▼
         Масив от указатели (heap)
         ┌──────┬──────┬──────┐
         │ ptr  │ ptr  │ ptr  │
         └──┬───┴──┬───┴──┬───┘
            │      │      │
            ▼      ▼      ▼
         Редове в heap:
         ┌─┬─┬─┐  ┌─┬─┬─┐  ┌─┬─┬─┐
         │1│2│3│  │4│5│6│  │7│8│9│
         └─┴─┴─┘  └─┴─┴─┘  └─┴─┴─┘
```

---

## 10) Функции с динамична памет

### Пример 1: Сума на динамичен масив

```cpp
int sumArray(int* arr, int size) {
    int sum = 0;
    for (int i = 0; i < size; i++) {
        sum += arr[i];
    }
    return sum;
}

int main() {
    int n = 5;
    int* arr = new int[n] {10, 20, 30, 40, 50};

    int total = sumArray(arr, n);
    std::cout << "Сума: " << total << std::endl;  // 150

    delete[] arr;
    return 0;
}
```

### Пример 2: Функция, която връща динамичен масив

```cpp
int* createArray(int size) {
    int* arr = new int[size];
    for (int i = 0; i < size; i++) {
        arr[i] = i + 1;
    }
    return arr;  // Връщаме указателя
}

int main() {
    int* myArray = createArray(5);

    for (int i = 0; i < 5; i++) {
        std::cout << myArray[i] << " ";  // 1 2 3 4 5
    }

    delete[] myArray;  // ВАЖНО: Извикващият е отговорен!
    return 0;
}
```

### Пример 3: Сума на 2D масив

```cpp
int sumMatrix(int** matrix, int rows, int cols) {
    int sum = 0;
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            sum += matrix[i][j];
        }
    }
    return sum;
}

int main() {
    int rows = 3, cols = 3;
    int** matrix = new int*[rows];

    for (int i = 0; i < rows; i++) {
        matrix[i] = new int[cols];
        for (int j = 0; j < cols; j++) {
            matrix[i][j] = i + j;
        }
    }

    int total = sumMatrix(matrix, rows, cols);
    std::cout << "Сума: " << total << std::endl;

    // Почистване
    for (int i = 0; i < rows; i++) {
        delete[] matrix[i];
    }
    delete[] matrix;

    return 0;
}
```

---

## 11) Чести грешки и как да ги избегнем

### ❌ Грешка 1: Използване след delete

```cpp
int* ptr = new int(42);
delete ptr;
std::cout << *ptr;  // ❌ Undefined behavior!
```

✅ **Решение:**

```cpp
int* ptr = new int(42);
delete ptr;
ptr = nullptr;      // Нулираме указателя
if (ptr != nullptr) {
    std::cout << *ptr;
}
```

### ❌ Грешка 2: Двойно delete

```cpp
int* ptr = new int(42);
delete ptr;
delete ptr;  // ❌ Double delete!
```

✅ **Решение:**

```cpp
int* ptr = new int(42);
delete ptr;
ptr = nullptr;  // След delete винаги nullptr
```

### ❌ Грешка 3: delete вместо delete[]

```cpp
int* arr = new int[10];
delete arr;  // ❌ Трябва delete[]!
```

✅ **Решение:**

```cpp
int* arr = new int[10];
delete[] arr;  // ✅ Правилно!
```

### ❌ Грешка 4: Забравяне на delete

```cpp
void function() {
    int* ptr = new int(42);
    // Забравяме delete!
}  // Memory leak!
```

✅ **Решение:**

```cpp
void function() {
    int* ptr = new int(42);
    // Работа с ptr...
    delete ptr;  // ✅ Винаги освобождаваме!
}
```

---

## 12) Указатели и динамична памет - важни концепции

### nullptr - нулев указател

```cpp
int* ptr = nullptr;  // Указател, който не сочи никъде

if (ptr == nullptr) {
    std::cout << "Указателят е нулев" << std::endl;
}

// Безопасно е да delete nullptr
delete ptr;  // Няма ефект, но е валидно
```

### Проверка преди delete

```cpp
int* ptr = new int(42);

// Добра практика
if (ptr != nullptr) {
    delete ptr;
    ptr = nullptr;
}
```

### Dangling pointer - висящ указател

```cpp
int* ptr = new int(42);
delete ptr;
// ptr все още съдържа адреса, но паметта е освободена!
// Това се нарича "dangling pointer"

ptr = nullptr;  // Решение: нулираме указателя
```

---

## 13) Практически примери

### Пример 1: Копиране на динамичен масив

```cpp
int* copyArray(int* source, int size) {
    int* copy = new int[size];
    for (int i = 0; i < size; i++) {
        copy[i] = source[i];
    }
    return copy;
}

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    int* dynamicCopy = copyArray(arr, 5);

    // Използваме копието...

    delete[] dynamicCopy;
    return 0;
}
```

### Пример 2: Обръщане на динамичен масив

```cpp
void reverseArray(int* arr, int size) {
    for (int i = 0; i < size / 2; i++) {
        int temp = arr[i];
        arr[i] = arr[size - 1 - i];
        arr[size - 1 - i] = temp;
    }
}

int main() {
    int n = 5;
    int* arr = new int[n] {1, 2, 3, 4, 5};

    reverseArray(arr, n);

    for (int i = 0; i < n; i++) {
        std::cout << arr[i] << " ";  // 5 4 3 2 1
    }

    delete[] arr;
    return 0;
}
```

### Пример 3: Транспониране на матрица

```cpp
int** transpose(int** matrix, int rows, int cols) {
    int** result = new int*[cols];
    for (int i = 0; i < cols; i++) {
        result[i] = new int[rows];
        for (int j = 0; j < rows; j++) {
            result[i][j] = matrix[j][i];
        }
    }
    return result;
}

// Не забравяйте да освободите паметта!
```

### Пример 4: Разменяне на стойности чрез указатели

```cpp
void swap(int* a, int* b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

int main() {
    int x = 5, y = 10;
    std::cout << "Преди: x = " << x << ", y = " << y << std::endl;

    swap(&x, &y);

    std::cout << "След: x = " << x << ", y = " << y << std::endl;
    return 0;
}
```

---

## 14) Кога да използваме Stack, кога Heap?

### 📚 Използвайте Stack когато:

- ✅ Размерът е **известен по време на компилация**
- ✅ Данните са **малки** (няколко KB)
- ✅ Животът на променливата е **кратък** (в рамките на функция)
- ✅ Искате **максимална скорост**

### 🏗️ Използвайте Heap когато:

- ✅ Размерът се **определя по време на изпълнение**
- ✅ Данните са **големи** (MB или повече)
- ✅ Нуждаете се от памет, която **живее извън функцията**
- ✅ Създавате **динамични структури** (списъци, дървета и др.)

---

## 15) Резюме

### Ключови точки за запомняне:

1. 📚 **Stack** е бърз, автоматичен, но ограничен
2. 🏗️ **Heap** е голям, гъвкав, но изисква ръчно управление
3. ⚡ Винаги освобождавайте заделената памет с `delete` или `delete[]`
4. 🛡️ Нулирайте указателите след `delete` с `= nullptr`
5. ⚠️ Внимавайте за Memory Leaks - те са най-честата грешка!
6. 📏 За масиви използвайте `new[]` и `delete[]`
7. 🔍 Проверявайте за `nullptr` преди да работите с указател

### Шаблон за безопасна работа:

```cpp
// 1. Заделяне
int* ptr = new int[size];

// 2. Проверка
if (ptr == nullptr) {
    // Грешка при заделяне
    return;
}

// 3. Използване
for (int i = 0; i < size; i++) {
    ptr[i] = i;
}

// 4. Освобождаване
delete[] ptr;
ptr = nullptr;
```

**Помнете:** Динамичната памет е мощен инструмент, но с голяма сила идва и голяма отговорност! 💪
