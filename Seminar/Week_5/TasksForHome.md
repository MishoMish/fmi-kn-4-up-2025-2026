# **ЗАДАЧИ ЗА ВКЪЩИ - СЕДМИЦА 5**

## **Функции - Задачи за упражнение**

---

## ЗАДАЧА 1: Запълване на матрица по правило

Да се напише функция `fillMatrix()`, която по дадени цели `n` и `m` числа създава и отпечатва матрица с `n` реда и `m` стълба. Матрицата се запълва по следния начин:

1. Елементите по **главния диагонал** са равни на номера на реда, в който се намират
2. Елементите **над главния диагонал** са равни на разликата на номера на стълба и номера на реда
3. Елементите **под главния диагонал** са равни на произведението на номера на реда и номера на стълба

**⚠️ Забележка:** Индексацията започва от 0!

### Пример:

```c++
// Вход:
4 4

// Изход:
0  1  2  3
0  1  1  2
0  2  2  2
0  3  6  3
```

**Обяснение:**

- `matrix[0][0] = 0` (диагонал, ред 0)
- `matrix[0][1] = 1` (над диагонала, 1 - 0 = 1)
- `matrix[1][0] = 0` (под диагонала, 1 \* 0 = 0)
- `matrix[2][3] = 1` (над диагонала, 3 - 2 = 1)
- `matrix[3][1] = 3` (под диагонала, 3 \* 1 = 3)

### Друг пример:

```c++
// Вход:
5 3

// Изход:
0  1  2
0  1  1
0  2  2
0  3  3
0  4  4
```

**⚠️ Важно:** Разгледайте как масив се подава към функция. При въпроси се свържете с нас или питайте в часа.

---

## ЗАДАЧА 2: Обръщане и конкатениране на низове

Напишете програма, която:

1. Приема `n` на брой символни низа от конзолата
2. Обръща всеки низ наобратно (използвайки написана от вас функция `reverseString()`)
3. Конкатенира обърнатите низове в реда на въвеждане
4. Извежда крайния резултат

### Пример:

```c++
// Вход:
3
abcde   // -> edcba
12345   // -> 54321
xyz     // -> zyx

// Изход:
edcba54321zyx
```

### Друг пример:

```c++
// Вход:
4
Hello   // -> olleH
World   // -> dlroW
FMI     // -> IMF
2024    // -> 4202

// Изход:
olleHdlroWIMF4202
```

**Подсказки:**

- Създайте функция `reverseString(char str[])` за обръщане на низ
- Използвайте `strcat()` или ръчно копиране за конкатенация
- Не забравяйте за терминиращата нула `'\0'`

---

## ЗАДАЧА 3: Fibonacci с рекурсия

Напишете функция `fibonacciRecursive()`, която **рекурсивно** намира n-тия елемент от редицата на Fibonacci.

**Определение на редицата:**

- F(0) = 0
- F(1) = 1
- F(n) = F(n-1) + F(n-2) за n > 1

**Редица:** 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, ...

### Примери:

```c++
// Вход:
0
// Изход:
0
```

```c++
// Вход:
5
// Изход:
5
```

```c++
// Вход:
10
// Изход:
55
```

```c++
// Вход:
15
// Изход:
610
```

### Анализ на подхода:

**Предимства:**

- ✅ Елегантен и лесен за разбиране код
- ✅ Директно следва математическата дефиниция
- ✅ Добър пример за рекурсия

**Недостатъци:**

- ❌ Много бавен за големи n (експоненциална сложност O(2ⁿ))
- ❌ Повтарящи се изчисления - много извиквания за едни и същи стойности
- ❌ Риск от stack overflow за големи n

### Визуализация на рекурсивните извиквания за F(5):

```
                    F(5)
                   /    \
              F(4)        F(3)
             /    \      /    \
        F(3)    F(2)  F(2)   F(1)
       /   \   /   \ /   \
   F(2) F(1) F(1) F(0) F(1) F(0)
  /   \
F(1) F(0)
```

**Забележете:** F(3) се изчислява 2 пъти, F(2) се изчислява 3 пъти, F(1) се изчислява 5 пъти!

### Бонус задача:

Напишете **итеративна** версия `fibonacciIterative()` и сравнете скоростта за n = 40.

**Итеративна версия (за справка):**

```c++
int fibonacciIterative(int n) {
    if (n <= 1) return n;

    int prev = 0, curr = 1;
    for (int i = 2; i <= n; i++) {
        int next = prev + curr;
        prev = curr;
        curr = next;
    }
    return curr;
}
```

**Сложност:** O(n) - много по-бързо!

---

## ЗАДАЧА 4: Проверка за перфектно число

Напишете функция `isPerfectNumber()`, която проверява дали дадено цяло число е **перфектно число**.

**Определение:** Перфектно число е естествено число, което е равно на сумата на своите собствени положителни делители (без самото себе си).

### Примери:

```c++
// 6 = 1 + 2 + 3  (делителите на 6 без самото 6)
isPerfectNumber(6) -> true

// 28 = 1 + 2 + 4 + 7 + 14
isPerfectNumber(28) -> true

// 496 = 1 + 2 + 4 + 8 + 16 + 31 + 62 + 124 + 248
isPerfectNumber(496) -> true

// 12 = 1 + 2 + 3 + 4 + 6 = 16 (не е равно на 12)
isPerfectNumber(12) -> false
```

**Първите перфектни числа:** 6, 28, 496, 8128

### Алгоритъм:

```c++
1. Намери всички делители на n (от 1 до n/2)
2. Събери делителите
3. Провери дали сумата е равна на n
```

---

## ЗАДАЧА 5: Конвертиране между бройни системи

Напишете две функции:

### A) `decimalToBinary(int n)`

Конвертира цяло число от десетична в двоична бройна система

```c++
// Примери:
decimalToBinary(10) -> 1010
decimalToBinary(25) -> 11001
decimalToBinary(255) -> 11111111
```

### B) `binaryToDecimal(long long binary)`

Конвертира цяло число от двоична в десетична бройна система

```c++
// Примери:
binaryToDecimal(1010) -> 10
binaryToDecimal(11001) -> 25
binaryToDecimal(11111111) -> 255
```

**Алгоритъм за decimal -> binary:**

```
Докато n > 0:
    остатък = n % 2
    добави остатък към резултата
    n = n / 2
Обърни резултата
```

**Алгоритъм за binary -> decimal:**

```
result = 0
power = 0
Докато binary > 0:
    цифра = binary % 10
    result = result + цифра × 2^power
    power++
    binary = binary / 10
```

---

## ЗАДАЧА 6: Цифров корен (Digital Root)

Напишете функция `digitalRoot()`, която намира цифровия корен на дадено число.

**Определение:** Цифровият корен се получава чрез повтарящо събиране на цифрите на числото, докато не се получи еднозначно число.

### Примери:

```c++
// 38 -> 3 + 8 = 11 -> 1 + 1 = 2
digitalRoot(38) -> 2

// 493193 -> 4+9+3+1+9+3 = 29 -> 2+9 = 11 -> 1+1 = 2
digitalRoot(493193) -> 2

// 12345 -> 1+2+3+4+5 = 15 -> 1+5 = 6
digitalRoot(12345) -> 6

// 999 -> 9+9+9 = 27 -> 2+7 = 9
digitalRoot(999) -> 9
```

### Алгоритъм:

```c++
Докато число >= 10:
    число = сума на цифрите на числото
Резултат = число
```

**Бонус:** Има и математическа формула за директно изчисляване:

```
digitalRoot(n) = 1 + ((n - 1) % 9)
```

(специален случай: digitalRoot(0) = 0)

---

## ЗАДАЧА 7: Сортиране на масив (Bubble Sort)

Напишете функция `bubbleSort()`, която сортира масив от цели числа във възходящ ред, използвайки алгоритъма **Bubble Sort**.

### Алгоритъм:

```
За i от 0 до n-1:
    За j от 0 до n-i-2:
        Ако arr[j] > arr[j+1]:
            Размени arr[j] и arr[j+1]
```

### Пример:

```c++
// Вход:
6
64 34 25 12 22 11

// След сортиране:
11 12 22 25 34 64
```

**Визуализация за масив {5, 3, 8, 4, 2}:**

```
Начало:     [5, 3, 8, 4, 2]
Итерация 1: [3, 5, 4, 2, 8]  (8 отива на края)
Итерация 2: [3, 4, 2, 5, 8]  (5 отива на правилното място)
Итерация 3: [3, 2, 4, 5, 8]  (4 отива на правилното място)
Итерация 4: [2, 3, 4, 5, 8]  (сортиран!)
```

**Времева сложност:** O(n²)

---

## ЗАДАЧА 8: Търсене в масив (Binary Search)

Напишете функция `binarySearch()`, която търси елемент в **сортиран** масив, използвайки алгоритъма **Binary Search** (двоично търсене).

Функцията връща индекса на елемента, или -1 ако не е намерен.

### Алгоритъм:

```
left = 0
right = n - 1

Докато left <= right:
    mid = (left + right) / 2

    Ако arr[mid] == target:
        Връща mid
    Ако arr[mid] < target:
        left = mid + 1
    Иначе:
        right = mid - 1

Връща -1 (не е намерен)
```

### Пример:

```c++
// Масив: [1, 3, 5, 7, 9, 11, 13, 15]

binarySearch(arr, 8, 7) -> 3    // намерен на индекс 3
binarySearch(arr, 8, 1) -> 0    // намерен на индекс 0
binarySearch(arr, 8, 15) -> 7   // намерен на индекс 7
binarySearch(arr, 8, 6) -> -1   // не е намерен
```

**Визуализация за търсене на 7:**

```
[1, 3, 5, 7, 9, 11, 13, 15]
 L        M              R     mid=9, 7<9, търси вляво

[1, 3, 5, 7]
 L     M  R                    mid=5, 7>5, търси вдясно

[7]
 L=M=R                         mid=7, намерен!
```

**Времева сложност:** O(log n) - много по-бързо от линейно търсене!

---

## ЗАДАЧА 9: Намиране на втори по големина елемент

Напишете функция `secondLargest()`, която намира втория по големина елемент в масив от цели числа.

**⚠️ Важно:**

- Ако всички елементи са еднакви, връщайте подходящо съобщение
- Не сортирайте масива!

### Примери:

```c++
// Масив: [12, 35, 1, 10, 34, 1]
secondLargest() -> 34

// Масив: [10, 5, 10]
secondLargest() -> 5

// Масив: [7, 7, 7, 7]
secondLargest() -> "Всички елементи са еднакви"
```

### Алгоритъм:

```
first = INT_MIN
second = INT_MIN

За всеки елемент:
    Ако елемент > first:
        second = first
        first = елемент
    Иначе ако елемент > second И елемент != first:
        second = елемент
```

---

## ЗАДАЧА 10 (БОНУС): Проверка за анаграми

Напишете функция `areAnagrams()`, която проверява дали два низа са **анаграми** (съдържат едни и същи букви с една и съща честота, но в различен ред).

**Игнорирайте:**

- Главни/малки букви
- Интервали

### Примери:

```c++
areAnagrams("listen", "silent") -> true
areAnagrams("Triangle", "Integral") -> true
areAnagrams("Hello", "World") -> false
areAnagrams("A gentleman", "Elegant man") -> true
areAnagrams("Programming", "Grammaring") -> false
```

### Подход 1 (лесен):

1. Сортирайте и двата низа
2. Сравнете дали са еднакви

### Подход 2 (оптимален):

1. Създайте честотен масив за буквите (26 елемента за a-z)
2. Увеличавайте брояча за първия низ
3. Намалявайте брояча за втория низ
4. Проверете дали всички бройки са 0
