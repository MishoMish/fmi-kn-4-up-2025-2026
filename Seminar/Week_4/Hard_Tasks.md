# **ТРУДНИ ЗАДАЧИ - СЕДМИЦА 4**

## **Указатели и Масиви - Експертно Ниво**

---

## **Задача 1: Динамична матрица с променлива големина на редовете**

Напишете програма, която:

1. Приема `n` - брой редове
2. За всеки ред приема `m[i]` - броя колони в този ред
3. Приема елементите на матрицата
4. Изчислява сумата на всеки ред и извежда реда с максимална сума

**Пример:**

```
Input:
3          // n (rows)
4          // m[0] (columns in row 0)
1 2 3 4    // elements of row 0
2          // m[1] (columns in row 1)
5 6        // elements of row 1
3          // m[2] (columns in row 2)
7 8 9      // elements of row 2

Output:
Row 2 has maximum sum: 24
Elements: 7 8 9
```

**Изисквания:**

- Използвайте динамична памет (`new`/`delete`)
- Всеки ред да има различна дължина
- Не забравяйте да освободите паметта

---

## **Задача 2: Merge на два сортирани масива**

Напишете програма, която приема два сортирани масива и ги обединява в един сортиран масив използвайки указатели.

**Пример:**

```
Input:
5                  // n1
1 3 5 7 9         // arr1
4                  // n2
2 4 6 8           // arr2

Output:
Merged array: 1 2 3 4 5 6 7 8 9
```

**Изисквания:**

- Използвайте три указателя (за всеки от двата масива + резултатния)
- Алгоритъмът трябва да е ефективен - O(n1 + n2)
- Резултатният масив трябва да е динамично заделен

---

## **Задача 3: Разместване на масив с k позиции**

Напишете програма, която приема масив и число `k` и премества всички елементи с `k` позиции наляво (циклично).

**Пример:**

```
Input:
7                      // n
1 2 3 4 5 6 7         // array
3                      // k

Output:
Original: 1 2 3 4 5 6 7
Rotated:  4 5 6 7 1 2 3
```

**Изисквания:**

- Използвайте pointer arithmetic
- Времева сложност O(n)
- Пространствена сложност O(1) - без допълнителен масив

---

## **Задача 4: Премахване на елемент от масив**

Напишете функция, която приема масив, неговата големина и индекс, и премахва елемента на този индекс, като измества всички следващи елементи наляво.

**Пример:**

```
Input:
6                    // n
10 20 30 40 50 60   // array
2                    // index to remove

Output:
Array after removal: 10 20 40 50 60
New size: 5
```

**Изисквания:**

- Функция с прототип: `void removeElement(int*& arr, int& size, int index)`
- Използвайте динамична памет и pointer arithmetic
- Валидирайте входа (проверка за валиден индекс)

---

## **Задача 5: Намиране на подмасив с максимална сума (Kadane's Algorithm)**

Напишете програма, която намира непрекъснат подмасив с максимална сума.

**Пример:**

```
Input:
9                              // n
-2 1 -3 4 -1 2 1 -5 4         // array

Output:
Maximum subarray sum: 6
Subarray: 4 -1 2 1 (indices 3 to 6)
```

**Изисквания:**

- Реализирайте Kadane's Algorithm
- Времева сложност O(n)
- Извеждайте както сумата, така и самия подмасив

---

## **Задача 6: Транспониране на матрица in-place**

Напишете програма, която транспонира квадратна матрица NxN без да използва допълнителна памет за друга матрица.

**Пример:**

```
Input:
3           // n
1 2 3       // row 0
4 5 6       // row 1
7 8 9       // row 2

Output:
Original matrix:
1 2 3
4 5 6
7 8 9

Transposed matrix:
1 4 7
2 5 8
3 6 9
```

**Изисквания:**

- In-place транспониране (без допълнителна матрица)
- Използвайте само указатели за достъп до елементи
- Времева сложност O(n²), пространствена O(1)

---

## **Задача 7: Намиране на дубликати в масив**

Напишете програма, която намира всички числа, които се срещат повече от веднъж в масив и брои колко пъти се среща всяко от тях.

**Пример:**

```
Input:
10                              // n
1 2 3 2 4 5 3 2 1 6            // array

Output:
Duplicates found:
1 appears 2 times
2 appears 3 times
3 appears 2 times
```

**Изисквания:**

- Не използвайте допълнителни структури (само масиви)
- Работете с числа в диапазона [1, 100]
- Използвайте bool масив за маркиране

---

## **Задача 8: Spiral Matrix Print**

Напишете програма, която приема матрица NxM и я извежда по спирала (отвън навътре).

**Пример:**

```
Input:
3 4        // rows, columns
1  2  3  4
5  6  7  8
9 10 11 12

Output:
Spiral order: 1 2 3 4 8 12 11 10 9 5 6 7
```

**Изисквания:**

- Използвайте 4 указателя/индекса (top, bottom, left, right)
- Обхождането трябва да е по посока на часовниковата стрелка
- Работи за произволни размери NxM

---

## **Задача 9: Палиндромна подредба**

Напишете програма, която проверява дали масив може да се преподреди така, че да образува палиндром.

**Пример:**

```
Input:
7                    // n
1 2 3 2 1 4 4       // array

Output:
Can form palindrome: YES
Example: 1 2 4 3 4 2 1
```

```
Input:
5                    // n
1 2 3 4 5           // array

Output:
Can form palindrome: NO
```

**Изисквания:**

- Проверете дали е възможно (най-много едно число с нечетна честота)
- Ако е възможно, изведете един пример за палиндромна подредба
- Използвайте масив за броене на честотите

---

## **Задача 10: Longest Increasing Subsequence (LIS)**

Напишете програма, която намира дължината на най-дългата нарастваща подредица в масив.

**Пример:**

```
Input:
8                           // n
10 9 2 5 3 7 101 18        // array

Output:
Length of LIS: 4
LIS: 2 3 7 101
```

**Изисквания:**

- Реализирайте динамично програмиране решение
- Времева сложност O(n²) е приемлива
- Извеждайте както дължината, така и една от възможните подредици

---

## **Задача 11: Matrix Multiplication**

Напишете програма, която умножава две матрици A[n x m] и B[m x p] и извежда резултата C[n x p].

**Пример:**

```
Input:
2 3        // n, m (dimensions of A)
1 2 3
4 5 6

3 2        // m, p (dimensions of B)
7 8
9 10
11 12

Output:
Result matrix C (2x2):
58  64
139 154
```

**Изисквания:**

- Динамично заделяне на всички три матрици
- Валидиране на размерите (броят колони на A трябва да е равен на броя редове на B)
- Правилно освобождаване на паметта

---

## **Задача 12: Find Missing Number in Range**

Напишете програма, която приема масив с n-1 числа в диапазона [1, n] и намира кое число липсва.

**Пример:**

```
Input:
5          // n (range is 1 to 5)
4          // size of array (n-1)
1 2 4 5    // array (missing 3)

Output:
Missing number: 3
```

**Изисквания:**

- Времева сложност O(n)
- Пространствена сложност O(1)
- Помислете за математическо решение (сума на първите n естествени числа)

---

## **Задача 13: Compress String**

Напишете програма, която компресира символен низ, замествайки последователни повтарящи се символи с брой + символ.

**Пример:**

```
Input:
aaabbccccdd

Output:
Compressed: a3b2c4d2
Original length: 11
Compressed length: 8
```

**Изисквания:**

- Ако компресираният низ е по-дълъг или равен на оригинала, върнете оригинала
- Работете директно с char масиви (не std::string)
- Използвайте указатели за обхождане

---

## **Задача 14: Two Sum Problem**

Напишете програма, която намира два индекса в масив, чиито елементи се сумират до дадено число.

**Пример:**

```
Input:
5                  // n
2 7 11 15 4       // array
9                  // target sum

Output:
Indices: 0 and 1
Values: 2 + 7 = 9
```

**Изисквания:**

- Времева сложност O(n²) с два цикъла е приемлива
- Ако няма решение, изведете подходящо съобщение
- Ако има повече от едно решение, изведете първото намерено

---

## **Задача 15: Run Length Encoding и Decoding**

Напишете две функции:

1. Encode - компресира символен низ
2. Decode - декомпресира символен низ

**Пример:**

```
Input (Encode):
AAAABBBCCDAA

Output (Encode):
A4B3C2D1A2

Input (Decode):
A4B3C2D1A2

Output (Decode):
AAAABBBCCDAA
```

**Изисквания:**

- Encode и Decode трябва да са обратими
- Работете с char масиви
- Използвайте указатели за ефективно обхождане

---

## **Бонус Задача: Memory Pool Allocator**

**Напреднало:** Реализирайте опростен memory pool allocator, който:

1. Заделя голям блок памет при инициализация
2. Предоставя малки блокове от този pool при заявка
3. Освобождава блокове и ги връща обратно в pool
4. Извежда статистика за използваната памет

**Изисквания:**

- Използвайте указатели за управление на свободните блокове
- Имплементирайте функции: `init()`, `allocate(size)`, `free(ptr)`, `stats()`
- Това е сложна задача, изискваща добро разбиране на указатели и памет

---

## **Съвети за решаване на трудните задачи:**

1. **Рисувайте диаграми** - визуализирайте паметта и указателите
2. **Тествайте с малки примери** - започнете с 3-4 елемента
3. **Проверявайте границите** - винаги валидирайте индекси
4. **Освобождавайте паметта** - всеки `new` трябва да има `delete`
5. **Използвайте дебъгер** - проследете стойностите на указателите
6. **Напишете помощни функции** - разделете сложните задачи на по-малки
7. **Документирайте кода** - коментирайте сложната логика
8. **Тествайте граничните случаи** - празни масиви, един елемент, много големи масиви

**Успех с решаването!** 🚀
